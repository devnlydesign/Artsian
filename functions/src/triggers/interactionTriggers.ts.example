
import * as functions from "firebase-functions";
import * as admin from "firebase-admin";

// Initialize admin if not already done
// if (admin.apps.length === 0) {
//   admin.initializeApp();
// }
// const db = admin.firestore();

/**
 * Triggered on creation of a new like.
 * - Increments likesCount on the parent content document.
 * - Creates a notification for the content creator.
 */
export const onCreateLike = functions.firestore
  .document("likes/{likeId}")
  .onCreate(async (snap, context) => {
    const likeData = snap.data();
    if (!likeData || !likeData.contentId || !likeData.contentType || !likeData.userId) {
      functions.logger.error("onCreateLike: Invalid like data", likeData);
      return null;
    }

    const contentRef = admin.firestore().doc(`${likeData.contentType}s/${likeData.contentId}`); // Assumes plural collection names

    try {
      await contentRef.update({
        likesCount: admin.firestore.FieldValue.increment(1),
      });
      functions.logger.info(`Incremented likesCount for ${likeData.contentType}/${likeData.contentId}`);

      // Create notification for content owner
      const contentSnap = await contentRef.get();
      const contentOwnerId = contentSnap.data()?.userId;
      const likerId = likeData.userId;

      if (contentOwnerId && contentOwnerId !== likerId) {
        const likerSnap = await admin.firestore().doc(`users/${likerId}`).get();
        const likerUsername = likerSnap.data()?.username || "Someone";
        
        await admin.firestore().collection("notifications").add({
          recipientId: contentOwnerId,
          senderId: likerId,
          senderName: likerUsername,
          senderAvatarUrl: likerSnap.data()?.profileImageUrl || null,
          type: "like",
          contentId: likeData.contentId,
          contentType: likeData.contentType,
          message: `${likerUsername} liked your ${likeData.contentType}.`,
          linkTo: `/${likeData.contentType}s/${likeData.contentId}`, // Example link
          read: false,
          createdAt: admin.firestore.FieldValue.serverTimestamp(),
        });
        functions.logger.info(`Notification created for like on ${likeData.contentType}/${likeData.contentId} to user ${contentOwnerId}`);
      }
    } catch (error) {
      functions.logger.error(
        `Error processing like for ${likeData.contentType}/${likeData.contentId}:`,
        error
      );
    }
    return null;
  });

/**
 * Triggered on deletion of a like.
 * - Decrements likesCount on the parent content document.
 * - (Future) Delete the corresponding notification.
 */
export const onDeleteLike = functions.firestore
  .document("likes/{likeId}")
  .onDelete(async (snap, context) => {
    const likeData = snap.data();
    if (!likeData || !likeData.contentId || !likeData.contentType) {
      functions.logger.error("onDeleteLike: Invalid like data", likeData);
      return null;
    }

    const contentRef = admin.firestore().doc(`${likeData.contentType}s/${likeData.contentId}`);
    try {
      await contentRef.update({
        likesCount: admin.firestore.FieldValue.increment(-1),
      });
      functions.logger.info(`Decremented likesCount for ${likeData.contentType}/${likeData.contentId}`);
      
      // TODO: Delete the specific 'like' notification if one exists.
      // This requires querying notifications based on senderId, contentId, contentType, and type='like'.
    } catch (error) {
      functions.logger.error(
        `Error processing unlike for ${likeData.contentType}/${likeData.contentId}:`,
        error
      );
    }
    return null;
  });

/**
 * Triggered on creation of a new comment.
 * - Increments commentsCount on the parent content document.
 * - Creates notifications for content creator and mentioned users.
 */
export const onCreateComment = functions.firestore
    .document("comments/{commentId}")
    .onCreate(async (snap, context) => {
        const commentData = snap.data();
        if (!commentData || !commentData.contentId || !commentData.contentType || !commentData.userId) {
            functions.logger.error("onCreateComment: Invalid comment data", commentData);
            return null;
        }

        const contentRef = admin.firestore().doc(`${commentData.contentType}s/${commentData.contentId}`);

        try {
            await contentRef.update({
                commentsCount: admin.firestore.FieldValue.increment(1)
            });
            functions.logger.info(`Incremented commentsCount for ${commentData.contentType}/${commentData.contentId}`);

            // Create notification for content owner
            const contentSnap = await contentRef.get();
            const contentOwnerId = contentSnap.data()?.userId;
            const commenterId = commentData.userId;

            if (contentOwnerId && contentOwnerId !== commenterId) {
                const commenterSnap = await admin.firestore().doc(`users/${commenterId}`).get();
                const commenterUsername = commenterSnap.data()?.username || "Someone";
                
                await admin.firestore().collection("notifications").add({
                    recipientId: contentOwnerId,
                    senderId: commenterId,
                    senderName: commenterUsername,
                    senderAvatarUrl: commenterSnap.data()?.profileImageUrl || null,
                    type: "comment",
                    contentId: commentData.contentId,
                    contentType: commentData.contentType,
                    message: `${commenterUsername} commented on your ${commentData.contentType}.`,
                    linkTo: `/${commentData.contentType}s/${commentData.contentId}#comment-${snap.id}`, // Example link
                    read: false,
                    createdAt: admin.firestore.FieldValue.serverTimestamp(),
                });
            }

            // TODO: Handle mentions in commentData.commentText and notify mentioned users
            // const mentionedUserIds = extractMentions(commentData.commentText);
            // for (const mentionedId of mentionedUserIds) { ... create notification ... }

        } catch (error) {
            functions.logger.error(`Error processing comment for ${commentData.contentType}/${commentData.contentId}:`, error);
        }
        return null;
    });

/**
 * Triggered on deletion of a comment.
 * - Decrements commentsCount on the parent content document.
 */
export const onDeleteComment = functions.firestore
    .document("comments/{commentId}")
    .onDelete(async (snap, context) => {
        const commentData = snap.data();
        if (!commentData || !commentData.contentId || !commentData.contentType) {
            functions.logger.error("onDeleteComment: Invalid comment data", commentData);
            return null;
        }
        const contentRef = admin.firestore().doc(`${commentData.contentType}s/${commentData.contentId}`);
        try {
            await contentRef.update({
                commentsCount: admin.firestore.FieldValue.increment(-1)
            });
            functions.logger.info(`Decremented commentsCount for ${commentData.contentType}/${commentData.contentId}`);
        } catch (error) {
             functions.logger.error(`Error decrementing commentsCount for ${commentData.contentType}/${commentData.contentId}:`, error);
        }
        return null;
    });


/**
 * Triggered on creation of a new follow relationship.
 * - Increments followersCount on the followed user.
 * - Increments followingCount on the follower.
 * - Creates a notification for the followed user.
 */
export const onFollowUser = functions.firestore
  .document("followers/{followId}")
  .onCreate(async (snap, context) => {
    const followData = snap.data();
    if (!followData || !followData.followerId || !followData.followingId) {
      functions.logger.error("onFollowUser: Invalid follow data", followData);
      return null;
    }

    const followerRef = admin.firestore().doc(`users/${followData.followerId}`);
    const followingRef = admin.firestore().doc(`users/${followData.followingId}`);

    const batch = admin.firestore().batch();
    batch.update(followerRef, { followingCount: admin.firestore.FieldValue.increment(1) });
    batch.update(followingRef, { followersCount: admin.firestore.FieldValue.increment(1) });

    try {
      await batch.commit();
      functions.logger.info(`Updated follow counts for ${followData.followerId} and ${followData.followingId}`);

      // Create notification for the followed user
      const followerSnap = await followerRef.get();
      const followerUsername = followerSnap.data()?.username || "Someone";
      
      await admin.firestore().collection("notifications").add({
        recipientId: followData.followingId,
        senderId: followData.followerId,
        senderName: followerUsername,
        senderAvatarUrl: followerSnap.data()?.profileImageUrl || null,
        type: "follow",
        linkTo: `/profile/${followData.followerId}`, // Example link
        read: false,
        createdAt: admin.firestore.FieldValue.serverTimestamp(),
      });
      functions.logger.info(`Follow notification created for ${followData.followingId}`);

    } catch (error) {
      functions.logger.error(
        `Error processing follow from ${followData.followerId} to ${followData.followingId}:`,
        error
      );
    }
    return null;
  });

/**
 * Triggered on deletion of a follow relationship (unfollow).
 * - Decrements followersCount and followingCount.
 */
export const onUnfollowUser = functions.firestore
  .document("followers/{followId}")
  .onDelete(async (snap, context) => {
    const followData = snap.data();
    if (!followData || !followData.followerId || !followData.followingId) {
      functions.logger.error("onUnfollowUser: Invalid follow data", followData);
      return null;
    }
    const followerRef = admin.firestore().doc(`users/${followData.followerId}`);
    const followingRef = admin.firestore().doc(`users/${followData.followingId}`);

    const batch = admin.firestore().batch();
    batch.update(followerRef, { followingCount: admin.firestore.FieldValue.increment(-1) });
    batch.update(followingRef, { followersCount: admin.firestore.FieldValue.increment(-1) });
    
    try {
      await batch.commit();
      functions.logger.info(`Updated unfollow counts for ${followData.followerId} and ${followData.followingId}`);
       // TODO: Delete the specific 'follow' notification if one exists.
    } catch (error) {
      functions.logger.error(
        `Error processing unfollow from ${followData.followerId} to ${followData.followingId}:`,
        error
      );
    }
    return null;
  });
    