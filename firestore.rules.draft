
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isResourceOwner(docData, fieldName) {
      return isAuthenticated() && request.auth.uid == docData[fieldName];
    }

    function isModerationStatusApproved(docData) {
      return docData.moderationStatus == 'approved';
    }
    
    function isPublishedAndApproved(docData) {
      return docData.isPublished == true && isModerationStatusApproved(docData);
    }

    // --- Users (Profiles) ---
    match /users/{userId} {
      allow read: if true; 

      allow create: if isOwner(userId) &&
                       request.resource.data.uid == userId &&
                       request.resource.data.keys().hasAll(['uid', 'email', 'fullName', 'username', 'isPremium', 'followersCount', 'followingCount', 'createdAt', 'updatedAt', 'moderationStatus']) &&
                       request.resource.data.isPremium == false &&
                       request.resource.data.followersCount == 0 &&
                       request.resource.data.followingCount == 0 &&
                       request.resource.data.moderationStatus == 'pending';


      allow update: if isOwner(userId) &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'uid', 'email', 
                           'isPremium', 'premiumSubscriptionId', 'premiumSubscriptionEndsAt', 
                           'stripeCustomerId', 
                           'followersCount', 'followingCount', 
                           'createdAt',
                           'moderationStatus', 'moderationInfo' // Only admin/moderator should update these post-initial-check
                         ]));
    }

    // --- Artworks (Crystalline Blooms) ---
    match /artworks/{artworkId} {
      allow read: if isPublishedAndApproved(resource.data) || isResourceOwner(resource.data, 'userId');

      allow create: if isResourceOwner(request.resource.data, 'userId') &&
                       request.resource.data.keys().hasAll(['userId', 'title', 'type', 'description', 'imageUrl', 'dataAiHint', 'layers', 'createdAt', 'updatedAt', 'isAmplified', 'amplifiedAt', 'moderationStatus', 'isPublished', 'status']) &&
                       request.resource.data.isAmplified == false &&
                       request.resource.data.moderationStatus == 'pending'; // isPublished and status handled by action

      allow update: if isResourceOwner(resource.data, 'userId') &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'userId', 'createdAt',
                           'moderationStatus', 'moderationInfo', // Admin/moderator controlled
                           'isPublished', 'status' // Server/Cloud Function controlled for scheduled posts
                         ])) &&
                       (
                         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAmplified', 'amplifiedAt']) ||
                         (
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isAmplified', 'amplifiedAt', 'updatedAt'])
                         )
                       );
      
      allow delete: if isResourceOwner(resource.data, 'userId');
    }

    // --- Reels ---
    match /reels/{reelId} {
      allow read: if isPublishedAndApproved(resource.data); // Or true if all reels are public

      allow create: if isResourceOwner(request.resource.data, 'userId') &&
                       request.resource.data.keys().hasAll(['userId', 'videoUrl', 'createdAt', 'updatedAt', 'moderationStatus', 'isPublished']) &&
                       request.resource.data.moderationStatus == 'pending' &&
                       request.resource.data.isPublished == true; // Or handle via server logic

      allow update: if isResourceOwner(resource.data, 'userId') &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'userId', 'createdAt', 'videoUrl', // videoUrl likely immutable or needs special handling
                           'moderationStatus', 'moderationInfo',
                           'isPublished', 'viewCount', 'likeCount', 'commentCount'
                         ]));
                         
      allow delete: if isResourceOwner(resource.data, 'userId');
    }

    // --- Connections (Follows) ---
    match /connections/{connectionId} {
      function isValidConnectionId() {
        let parts = connectionId.split('_');
        return parts.size() == 2 && parts[0] != parts[1]; 
      }
      
      allow read: if isAuthenticated();

      allow create: if isValidConnectionId() &&
                       isResourceOwner(request.resource.data, 'followerId') && 
                       request.resource.data.followerId == connectionId.split('_')[0] && 
                       request.resource.data.followedId == connectionId.split('_')[1] && 
                       request.resource.data.keys().hasAll(['followerId', 'followedId', 'createdAt']);

      allow delete: if isResourceOwner(resource.data, 'followerId'); 
    }

    // --- Genesis Trails ---
    match /genesisTrails/{trailId} {
      allow read, create: if isResourceOwner(request.resource.data, 'userId') &&
                              (request.method == 'create' ? request.resource.data.keys().hasAll(['userId', 'input', 'output', 'projectTitle', 'createdAt']) : true);
      allow update, delete: if false;
    }

    // --- Muse Ideas ---
    match /museIdeas/{ideaId} {
      allow read, create: if isResourceOwner(request.resource.data, 'userId') &&
                              (request.method == 'create' ? request.resource.data.keys().hasAll(['userId', 'input', 'output', 'createdAt']) : true);
      allow update, delete: if false;
    }

    // --- Communities & Posts ---
    match /communities/{communityId} {
      allow read: if true; 
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, 'creatorId') &&
                       request.resource.data.keys().hasAll(['name', 'description', 'creatorId', 'creatorName', 'imageUrl', 'dataAiHint', 'memberCount', 'createdAt', 'updatedAt']) &&
                       request.resource.data.memberCount == 1; 
      allow update: if isResourceOwner(resource.data, 'creatorId') && 
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'creatorId', 'creatorName', 'memberCount', 'createdAt'
                         ]));

      match /posts/{postId} {
        allow read: if isModerationStatusApproved(resource.data);
        allow create: if isAuthenticated() &&
                         isResourceOwner(request.resource.data, 'creatorId') &&
                         exists(/databases/$(database)/documents/communityMemberships/$(request.auth.uid + '_' + communityId)) &&
                         request.resource.data.keys().hasAll(['communityId', 'creatorId', 'creatorName', 'content', 'createdAt', 'updatedAt', 'moderationStatus']) &&
                         request.resource.data.communityId == communityId &&
                         request.resource.data.moderationStatus == 'pending';
        allow update: if isResourceOwner(resource.data, 'creatorId') &&
                         !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'communityId', 'creatorId', 'creatorName', 'createdAt', 'moderationStatus', 'moderationInfo'
                         ]));
        allow delete: if isResourceOwner(resource.data, 'creatorId');
      }
    }

    match /communityMemberships/{membershipId} {
      function isCorrectMembershipIdFormat() {
        let parts = membershipId.split('_');
        return parts.size() == 2;
      }
      allow read: if isAuthenticated() && 
                     (isOwner(membershipId.split('_')[0]) || isResourceOwner(get(/databases/$(database)/documents/communities/$(membershipId.split('_')[1])).data, 'creatorId'));

      allow create: if isAuthenticated() &&
                       isCorrectMembershipIdFormat() &&
                       isOwner(request.resource.data.userId) && 
                       request.resource.data.userId == membershipId.split('_')[0] &&
                       request.resource.data.communityId == membershipId.split('_')[1] &&
                       request.resource.data.keys().hasAll(['userId', 'communityId', 'joinedAt', 'role']) &&
                       (request.resource.data.role == 'member' || (request.resource.data.role == 'admin' && isResourceOwner(get(/databases/$(database)/documents/communities/$(request.resource.data.communityId)).data, 'creatorId')));

      allow delete: if isAuthenticated() &&
                       isCorrectMembershipIdFormat() &&
                       isOwner(resource.data.userId) && 
                       resource.data.userId == membershipId.split('_')[0];
    }

    // --- Private Biomes & Memberships ---
    match /biomes/{biomeId} {
      allow read: if true; 
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, 'creatorId') &&
                       request.resource.data.keys().hasAll(['name', 'description', 'creatorId', 'creatorName', 'imageUrl', 'dataAiHint', 'memberCount', 'accessType', 'createdAt', 'updatedAt']) &&
                       request.resource.data.memberCount == 1 &&
                       (request.resource.data.accessType == 'free' || request.resource.data.stripePriceId != null);

      allow update: if isResourceOwner(resource.data, 'creatorId') && 
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'creatorId', 'creatorName', 'memberCount', 'createdAt', 'accessType', 'stripePriceId' 
                         ]));
    }

    match /biomeMemberships/{membershipId} { 
       function isCorrectBiomeMembershipIdFormat() {
        let parts = membershipId.split('_');
        return parts.size() == 2;
      }
      function isBiomeMemberOrOwner() {
        return isAuthenticated() && (isOwner(resource.data.userId) || isResourceOwner(get(/databases/$(database)/documents/biomes/$(resource.data.biomeId)).data, 'creatorId'));
      }

      allow read: if isBiomeMemberOrOwner();
      
      allow create: if (isAuthenticated() && 
                        isCorrectBiomeMembershipIdFormat() &&
                        isOwner(request.resource.data.userId) &&
                        request.resource.data.userId == membershipId.split('_')[0] &&
                        request.resource.data.biomeId == membershipId.split('_')[1] &&
                        (
                          (get(/databases/$(database)/documents/biomes/$(request.resource.data.biomeId)).data.accessType == 'free' && request.resource.data.status == 'active') ||
                          (get(/databases/$(database)/documents/biomes/$(request.resource.data.biomeId)).data.accessType == 'paid' && request.resource.data.status == 'pending_payment') || // Initial status for paid
                          (request.resource.data.role == 'owner') // Owner during biome creation
                        ) &&
                        request.resource.data.keys().hasAll(['userId', 'biomeId', 'role', 'joinedAt', 'status'])
                       ) ||
                       // Allow webhook/server to create/update with full details
                       (request.auth == null && request.origin == 'firebase'); // Basic check, needs refinement for real webhooks

      allow update: if (request.auth == null && request.origin == 'firebase'); // Only server/webhook can update (e.g. status after payment)

      allow delete: if isAuthenticated() && 
                       isCorrectBiomeMembershipIdFormat() &&
                       isOwner(resource.data.userId) && 
                       resource.data.userId == membershipId.split('_')[0];
    }
    
    // --- Shop Items ---
    match /shopItems/{itemId} {
      allow read: if isPublishedAndApproved(resource.data) || (isAuthenticated() && isResourceOwner(resource.data, 'artistId'));
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, 'artistId') &&
                       request.resource.data.keys().hasAll(['artistId', 'artistName', 'name', 'description', 'priceInCents', 'imageUrl', 'createdAt', 'updatedAt', 'isPublished', 'moderationStatus']) &&
                       request.resource.data.priceInCents >= 50 && 
                       request.resource.data.moderationStatus == 'pending';
      allow update: if isAuthenticated() && isResourceOwner(resource.data, 'artistId') &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'artistId', 'createdAt', 'moderationStatus', 'moderationInfo'
                         ]));
      allow delete: if isAuthenticated() && isResourceOwner(resource.data, 'artistId');
    }

    // --- Orders ---
    match /orders/{orderId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data, 'userId');
      allow create, update, delete: if false; // Server/webhook controlled
    }

    // --- Notifications ---
    match /notifications/{notificationId} {
      allow read: if isResourceOwner(resource.data, 'recipientId');
      allow update: if isResourceOwner(resource.data, 'recipientId') &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
      allow create: if false; 
      allow delete: if isResourceOwner(resource.data, 'recipientId'); 
    }

    // --- Chat Channels & Messages ---
    match /chatChannels/{channelId} {
      function isChannelMember() {
        return isAuthenticated() && request.auth.uid in resource.data.members;
      }
      function isChannelMemberForCreate(channelData) {
        return isAuthenticated() && request.auth.uid in channelData.members;
      }
      function isValidChannelIdFormatAndMembers() {
        let parts = channelId.split('_');
        return parts.size() == 2 && parts[0] < parts[1] && 
               request.resource.data.members.size() == 2 && // Ensure exactly two members
               request.resource.data.members[0] == parts[0] && 
               request.resource.data.members[1] == parts[1];
      }

      allow read: if isChannelMember();
      
      allow create: if isChannelMemberForCreate(request.resource.data) &&
                       isValidChannelIdFormatAndMembers() &&
                       request.resource.data.id == channelId &&
                       request.resource.data.keys().hasAll(['id', 'members', 'memberInfo', 'lastMessageText', 'lastMessageTimestamp', 'lastMessageSenderId', 'unreadCounts', 'createdAt', 'updatedAt']);

      allow update: if isChannelMember() &&
                       (
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessageText', 'lastMessageTimestamp', 'lastMessageSenderId', 'updatedAt'])) ||
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts', 'updatedAt']) && 
                           request.resource.data.unreadCounts[request.auth.uid] <= resource.data.unreadCounts[request.auth.uid])
                       );
      allow delete: if false; 

      match /messages/{messageId} {
        function isChannelMemberFromParentDoc() {
          return isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chatChannels/$(channelId)).data.members;
        }
        
        allow read: if isChannelMemberFromParentDoc();
        
        allow create: if isChannelMemberFromParentDoc() && 
                         isOwner(request.resource.data.senderId) && 
                         request.resource.data.channelId == channelId && 
                         request.resource.data.keys().hasAll(['channelId', 'senderId', 'text', 'timestamp', 'senderName']); 
                         
        allow update, delete: if false; 
      }
    }
  }
}
    