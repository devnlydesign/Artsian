
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isResourceOwner(resourceUserId) {
      return request.auth.uid == resourceUserId;
    }
    
    function isModerationStatusApproved(status) {
      return status == 'approved';
    }

    function isPublishedAndApproved(resourceData) {
      return resourceData.isPublished == true && isModerationStatusApproved(resourceData.moderationStatus);
    }
    
    // User Profiles
    match /users/{userId} {
      allow read: if true; // Publicly readable, or use resource.data.isPublic if you add such a field
      allow create: if isOwner(userId) && 
                      request.resource.data.uid == userId &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.followersCount == 0 &&
                      request.resource.data.followingCount == 0 &&
                      request.resource.data.isPremium == false &&
                      request.resource.data.moderationStatus == 'pending' &&
                      !request.resource.data.key().startsWith('stripeCustomerId') && // Cannot set on create
                      !request.resource.data.key().startsWith('premiumSubscriptionId') &&
                      !request.resource.data.key().startsWith('premiumSubscriptionEndsAt');
      allow update: if isOwner(userId) &&
                      request.resource.data.uid == userId && // UID cannot change
                      request.resource.data.email == resource.data.email && // Email cannot change client-side once set
                      request.resource.data.createdAt == resource.data.createdAt && // Cannot change creation time
                      request.resource.data.updatedAt == request.time &&
                      // Prevent client from updating sensitive fields
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny([
                        'followersCount', 'followingCount', 'isPremium', 'stripeCustomerId', 
                        'premiumSubscriptionId', 'premiumSubscriptionEndsAt', 'moderationStatus', 'moderationInfo'
                      ]);
      allow delete: if false; // Generally users should not delete their own profiles directly
    }

    // Artworks
    match /artworks/{artworkId} {
      allow read: if isPublishedAndApproved(resource.data) || isResourceOwner(resource.data.userId);
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.userId) &&
                      request.resource.data.moderationStatus == 'pending';
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.userId) &&
                       // Prevent client from directly publishing scheduled/draft items or changing status from scheduled
                       (resource.data.status != 'scheduled' || request.resource.data.status == 'scheduled') && 
                       (resource.data.status != 'published' || request.resource.data.status == 'published') &&
                       (resource.data.isPublished == false || request.resource.data.isPublished == false) &&
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny([
                        'userId', 'createdAt', 'isPublished', 'status', 
                        'moderationStatus', 'moderationInfo', 'isAmplified', 'amplifiedAt'
                      ]);
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.userId);
    }

    // Connections (Follows)
    match /connections/{connectionId} {
      allow read: if isAuthenticated();
      allow create: if isAuthenticated() && 
                      request.resource.data.followerId == request.auth.uid &&
                      connectionId == request.auth.uid + '_' + request.resource.data.followedId;
      allow delete: if isAuthenticated() && 
                      resource.data.followerId == request.auth.uid &&
                      connectionId == request.auth.uid + '_' + resource.data.followedId;
      allow update: if false;
    }
    
    // Genesis Trails
    match /genesisTrails/{trailId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data.userId);
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data.userId);
      allow update, delete: if false; // Immutable after creation by client
    }

    // Muse Ideas
    match /museIdeas/{ideaId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data.userId);
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data.userId);
      allow update, delete: if false; // Immutable after creation by client
    }

    // Communities
    match /communities/{communityId} {
      allow read: if true; // Publicly readable
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.creatorId) &&
                      request.resource.data.memberCount == 1;
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.creatorId) &&
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['creatorId', 'createdAt', 'memberCount']);
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.creatorId) && resource.data.memberCount <=1; // Only if empty and by creator

      // Community Posts
      match /posts/{postId} {
        allow read: if isModerationStatusApproved(resource.data.moderationStatus);
        allow create: if isAuthenticated() && 
                        isResourceOwner(request.resource.data.creatorId) &&
                        // User must be a member of the community to post
                        exists(/databases/$(database)/documents/communityMemberships/$(request.auth.uid)_$(communityId)) &&
                        request.resource.data.moderationStatus == 'pending';
        allow update: if isAuthenticated() && 
                        isResourceOwner(resource.data.creatorId) &&
                        !request.resource.data.diff(resource.data).affectedKeys().hasAny([
                          'communityId', 'creatorId', 'createdAt', 'moderationStatus', 'moderationInfo'
                        ]);
        allow delete: if isAuthenticated() && (isResourceOwner(resource.data.creatorId) || 
                        get(/databases/$(database)/documents/communityMemberships/$(request.auth.uid)_$(communityId)).data.role == 'admin');
      }
    }

    // Community Memberships
    match /communityMemberships/{membershipId} {
      allow read: if isAuthenticated() && (isResourceOwner(resource.data.userId) || 
                    isResourceOwner(get(/databases/$(database)/documents/communities/$(resource.data.communityId)).data.creatorId) );
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.userId) &&
                      membershipId == request.auth.uid + '_' + request.resource.data.communityId &&
                      request.resource.data.role == 'member'; // Client can only join as member
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.userId);
      allow update: if isAuthenticated() && 
                      (isResourceOwner(get(/databases/$(database)/documents/communities/$(resource.data.communityId)).data.creatorId) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['role']) ); // Admin can change role
    }

    // Biomes
    match /biomes/{biomeId} {
      allow read: if true; // Publicly readable (details like name, description)
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.creatorId) &&
                      request.resource.data.memberCount == 1 &&
                      (request.resource.data.accessType == 'free' || 
                       (request.resource.data.accessType == 'paid' && request.resource.data.stripePriceId != null));
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.creatorId) &&
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny(['creatorId', 'createdAt', 'memberCount', 'accessType', 'stripePriceId']); // Sensitive fields not client-updatable
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.creatorId) && resource.data.memberCount <=1;
      
      // Biome Posts (if you add them - example)
      // match /posts/{postId} { ... }
    }
    
    // Biome Memberships
    match /biomeMemberships/{membershipId} {
      allow read: if isAuthenticated() && 
                      (isResourceOwner(resource.data.userId) || 
                       isResourceOwner(get(/databases/$(database)/documents/biomes/$(resource.data.biomeId)).data.creatorId));
      // Client creation for 'free' biomes, or after webhook for 'paid' ones.
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.userId) &&
                      membershipId == request.auth.uid + '_' + request.resource.data.biomeId &&
                      request.resource.data.role == 'member' &&
                      (get(/databases/$(database)/documents/biomes/$(request.resource.data.biomeId)).data.accessType == 'free' || 
                       request.resource.data.status == 'pending_payment'); // Client might create pending record for paid
      allow update: if isAuthenticated() && 
                      isResourceOwner(get(/databases/$(database)/documents/biomes/$(resource.data.biomeId)).data.creatorId) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['role', 'status']); // Owner can manage role/status
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.userId);
    }

    // Shop Items
    match /shopItems/{itemId} {
      allow read: if isPublishedAndApproved(resource.data) || isResourceOwner(resource.data.artistId);
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.artistId) &&
                      request.resource.data.moderationStatus == 'pending';
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.artistId) &&
                       !request.resource.data.diff(resource.data).affectedKeys().hasAny([
                        'artistId', 'createdAt', 'moderationStatus', 'moderationInfo'
                      ]);
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.artistId);
    }

    // Orders
    match /orders/{orderId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data.userId);
      // Orders are created and updated via webhooks or trusted server code, not directly by clients.
      allow create, update, delete: if false; 
    }

    // Notifications
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data.recipientId);
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.recipientId) &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']);
      allow create, delete: if false; // Created by server, client can mark read (or delete if allowed)
    }
    
    // Reels
    match /reels/{reelId} {
      allow read: if isPublishedAndApproved(resource.data) || isResourceOwner(resource.data.userId);
      allow create: if isAuthenticated() && 
                      isResourceOwner(request.resource.data.userId) &&
                      request.resource.data.moderationStatus == 'pending';
      allow update: if isAuthenticated() && 
                      isResourceOwner(resource.data.userId) &&
                      !request.resource.data.diff(resource.data).affectedKeys().hasAny([
                        'userId', 'createdAt', 'moderationStatus', 'moderationInfo', 'viewCount', 'likeCount', 'commentCount'
                      ]);
      allow delete: if isAuthenticated() && isResourceOwner(resource.data.userId);
    }

    // Legal Documents
    match /LegalDocuments/{documentId} {
      allow read: if true; // Publicly readable
      // Writes (create, update, delete) should be admin-only
      // This assumes you have a way to identify admins (e.g., custom claim)
      allow write: if request.auth.token.admin == true; // Conceptual: adjust to your admin role implementation
    }

    // Chat Channels & Messages
    match /chatChannels/{channelId} {
      allow read, update: if isAuthenticated() && request.auth.uid in resource.data.members;
      allow create: if isAuthenticated() && 
                      request.auth.uid in request.resource.data.members &&
                      request.resource.data.members.size() == 2 && // Only 1-on-1 chats for now
                      // Ensure channelId is correctly formed from the two members
                      (channelId == request.auth.uid + '_' + request.resource.data.members[1] || 
                       channelId == request.resource.data.members[0] + '_' + request.auth.uid);
      allow delete: if false; // Channels are not typically deleted by users

      match /messages/{messageId} {
        allow read: if isAuthenticated() && request.auth.uid in get(/databases/$(database)/documents/chatChannels/$(channelId)).data.members;
        allow create: if isAuthenticated() && 
                        request.auth.uid in get(/databases/$(database)/documents/chatChannels/$(channelId)).data.members &&
                        request.resource.data.senderId == request.auth.uid;
        allow update, delete: if isAuthenticated() && 
                                resource.data.senderId == request.auth.uid &&
                                // Optional: Allow updates/deletes only for a short period
                                request.time < resource.data.timestamp + duration.value(5, 'm'); 
      }
    }

  }
}
