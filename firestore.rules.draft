
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    function isResourceOwner(docData, ownerField) {
      return isAuthenticated() && request.auth.uid == docData[ownerField];
    }

    function isModerationStatusApproved(docData) {
      return docData.moderationStatus == 'approved';
    }

    function isPublishedAndApproved(docData) {
      return docData.isPublished == true && isModerationStatusApproved(docData);
    }

    // --- Users (Profiles) ---
    match /users/{userId} {
      // Public profiles are generally readable, especially basic info for connections/mentions
      allow read: if true; 
      
      // User can create their own profile document, typically during onboarding
      allow create: if isOwner(userId) &&
                       request.resource.data.uid == userId &&
                       // Validate essential fields for new profiles
                       request.resource.data.keys().hasAll(['uid', 'email', 'createdAt', 'updatedAt']) &&
                       request.resource.data.isPremium == false && // Cannot set premium on client-side creation
                       request.resource.data.followersCount == 0 &&
                       request.resource.data.followingCount == 0 &&
                       request.resource.data.moderationStatus == 'pending'; // New profiles start as pending

      // User can update their own profile
      allow update: if isOwner(userId) &&
                       // Prevent client from modifying these fields directly
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'uid', 'email', // Email typically verified and not directly updatable
                           'isPremium', 'premiumSubscriptionId', 'premiumSubscriptionEndsAt', // Stripe webhook controlled
                           'stripeCustomerId', // Stripe webhook/server controlled
                           'followersCount', 'followingCount', // Server action controlled
                           'createdAt',
                           'moderationStatus', 'moderationInfo' // Admin/moderator controlled post-creation
                         ]));
      
      // Users typically don't delete their own main profile document directly
      allow delete: if false; // Handle account deletion via a server process
    }

    // --- Artworks (Crystalline Blooms) ---
    match /artworks/{artworkId} {
      allow read: if isPublishedAndApproved(resource.data) || isResourceOwner(resource.data, "userId");

      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "userId") &&
                       request.resource.data.keys().hasAll(['userId', 'title', 'type', 'description', 'imageUrl', 'dataAiHint', 'layers', 'createdAt', 'updatedAt', 'isAmplified', 'amplifiedAt', 'isPublished', 'status', 'moderationStatus']) &&
                       request.resource.data.isAmplified == false &&
                       (request.resource.data.status == 'pending_moderation' || request.resource.data.status == 'scheduled' || request.resource.data.status == 'draft') && // initial valid statuses
                       request.resource.data.moderationStatus == 'pending';

      allow update: if isAuthenticated() && isResourceOwner(resource.data, "userId") &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'userId', 'createdAt',
                           // status and isPublished are server/webhook controlled for scheduled items
                           // moderationStatus and moderationInfo are admin/moderator controlled
                           'status', 'isPublished', 'moderationStatus', 'moderationInfo' 
                         ])) &&
                       // Specific rule for client-side amplification update (via server action is better)
                       (
                         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['isAmplified', 'amplifiedAt']) ||
                         (
                           request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isAmplified', 'amplifiedAt', 'updatedAt'])
                         )
                       );
      
      allow delete: if isAuthenticated() && isResourceOwner(resource.data, "userId");
    }

    // --- Connections (Follows) ---
    match /connections/{connectionId} {
      function isValidConnectionId() {
        let parts = connectionId.split('_');
        return parts.size() == 2 && parts[0] != parts[1];
      }
      
      allow read: if isAuthenticated(); // Users can read connection docs to see who follows whom if needed by app logic

      allow create: if isValidConnectionId() &&
                       isOwner(request.resource.data.followerId) && // Only follower can initiate
                       request.resource.data.followerId == connectionId.split('_')[0] && 
                       request.resource.data.followedId == connectionId.split('_')[1] &&
                       request.resource.data.keys().hasAll(['followerId', 'followedId', 'createdAt']);

      allow delete: if isOwner(resource.data.followerId); // Only follower can unfollow
    }

    // --- Genesis Trails ---
    match /genesisTrails/{trailId} {
      allow read: if isResourceOwner(resource.data, "userId");
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "userId") &&
                       request.resource.data.keys().hasAll(['userId', 'input', 'output', 'projectTitle', 'createdAt']);
      allow update, delete: if false; // Immutable by client after creation
    }

    // --- Muse Ideas ---
    match /museIdeas/{ideaId} {
      allow read: if isResourceOwner(resource.data, "userId");
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "userId") &&
                       request.resource.data.keys().hasAll(['userId', 'input', 'output', 'createdAt']);
      allow update, delete: if false; // Immutable by client after creation
    }

    // --- Communities ---
    match /communities/{communityId} {
      allow read: if true; // Public communities
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "creatorId") &&
                       request.resource.data.keys().hasAll(['name', 'description', 'creatorId', 'creatorName', 'imageUrl', 'dataAiHint', 'memberCount', 'createdAt', 'updatedAt']) &&
                       request.resource.data.memberCount == 1; 
      
      allow update: if isAuthenticated() && isResourceOwner(resource.data, "creatorId") && // Only creator can update community details
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'creatorId', 'creatorName', 'memberCount', 'createdAt'
                         ]));
      // delete: typically by admin or server process

      // --- Community Posts ---
      match /posts/{postId} {
        allow read: if isModerationStatusApproved(resource.data); // Only approved posts readable by public
        allow create: if isAuthenticated() &&
                         isResourceOwner(request.resource.data, "creatorId") &&
                         exists(/databases/$(database)/documents/communityMemberships/$(request.auth.uid + '_' + communityId)) && // Must be a member
                         request.resource.data.keys().hasAll(['communityId', 'creatorId', 'creatorName', 'content', 'createdAt', 'updatedAt', 'moderationStatus']) &&
                         request.resource.data.communityId == communityId &&
                         request.resource.data.moderationStatus == 'pending';
        
        allow update: if isAuthenticated() && isResourceOwner(resource.data, "creatorId") &&
                         !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'communityId', 'creatorId', 'creatorName', 'createdAt', 'moderationStatus', 'moderationInfo'
                         ]));
        allow delete: if isAuthenticated() && isResourceOwner(resource.data, "creatorId");
        // Future: allow community admins/moderators to delete/update moderationStatus
      }
    }

    // --- Community Memberships ---
    match /communityMemberships/{membershipId} { // membershipId: {userId}_{communityId}
      function isCorrectMembershipIdFormat() {
        let parts = membershipId.split('_');
        return parts.size() == 2;
      }
      function isMemberRequestingOwnDoc() {
          return isCorrectMembershipIdFormat() && request.auth.uid == membershipId.split('_')[0];
      }

      allow read: if isAuthenticated() && 
                     (isMemberRequestingOwnDoc() || 
                      isResourceOwner(get(/databases/$(database)/documents/communities/$(resource.data.communityId)).data, "creatorId")); // Member or community creator can read

      allow create: if isAuthenticated() &&
                       isCorrectMembershipIdFormat() &&
                       isOwner(request.resource.data.userId) && // User creates their own membership
                       request.resource.data.userId == membershipId.split('_')[0] &&
                       request.resource.data.communityId == membershipId.split('_')[1] &&
                       request.resource.data.keys().hasAll(['userId', 'communityId', 'joinedAt', 'role']) &&
                       request.resource.data.role == 'member'; // Client can only join as member

      allow delete: if isAuthenticated() &&
                       isCorrectMembershipIdFormat() &&
                       isOwner(resource.data.userId) && // User deletes their own membership
                       resource.data.userId == membershipId.split('_')[0];
    }

    // --- Private Biomes ---
    match /biomes/{biomeId} {
      allow read: if true; // Biome details are public for discovery
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "creatorId") &&
                       request.resource.data.keys().hasAll(['name', 'description', 'creatorId', 'creatorName', 'imageUrl', 'dataAiHint', 'memberCount', 'accessType', 'createdAt', 'updatedAt']) &&
                       request.resource.data.memberCount == 1 &&
                       (request.resource.data.accessType == 'free' || request.resource.data.stripePriceId != null);

      allow update: if isAuthenticated() && isResourceOwner(resource.data, "creatorId") &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'creatorId', 'creatorName', 'memberCount', 'createdAt'
                         ]));
      // delete: typically by admin or server process
    }

    // --- Biome Memberships ---
    match /biomeMemberships/{membershipId} { // membershipId: {userId}_{biomeId}
      function isCorrectBiomeMembershipIdFormat() {
        let parts = membershipId.split('_');
        return parts.size() == 2;
      }
       function isBiomeMemberRequestingOwnDoc() {
          return isCorrectBiomeMembershipIdFormat() && request.auth.uid == membershipId.split('_')[0];
      }
      function isBiomeOwnerOrAdminOfMembership() {
        let biomeDoc = get(/databases/$(database)/documents/biomes/$(resource.data.biomeId)).data;
        return isResourceOwner(biomeDoc, "creatorId"); // Simple owner check, extend for admin roles
      }

      allow read: if isAuthenticated() && (isBiomeMemberRequestingOwnDoc() || isBiomeOwnerOrAdminOfMembership());
      
      // Create for free biomes by client, paid biomes by webhook.
      allow create: if isAuthenticated() && 
                       isCorrectBiomeMembershipIdFormat() && 
                       isOwner(request.resource.data.userId) &&
                       request.resource.data.userId == membershipId.split('_')[0] &&
                       request.resource.data.biomeId == membershipId.split('_')[1] &&
                       request.resource.data.keys().hasAll(['userId', 'biomeId', 'role', 'joinedAt', 'status']) &&
                       request.resource.data.role == (get(/databases/$(database)/documents/biomes/$(request.resource.data.biomeId)).data.creatorId == request.auth.uid ? 'owner' : 'member') && // owner if creating own biome, member if joining
                       get(/databases/$(database)/documents/biomes/$(request.resource.data.biomeId)).data.accessType == 'free' &&
                       request.resource.data.status == 'active';
                       // Paid biome memberships are created/activated by webhook after payment.

      allow update: if false; // All membership updates (status, role, Stripe details) should be via server actions or webhooks.

      allow delete: if isAuthenticated() &&
                       isCorrectBiomeMembershipIdFormat() &&
                       isOwner(resource.data.userId) && 
                       resource.data.userId == membershipId.split('_')[0]; // User leaves a biome
    }

    // --- Shop Items ---
    match /shopItems/{itemId} {
      allow read: if isPublishedAndApproved(resource.data) || (isAuthenticated() && isResourceOwner(resource.data, "artistId"));
      
      allow create: if isAuthenticated() && isResourceOwner(request.resource.data, "artistId") &&
                       request.resource.data.keys().hasAll(['artistId', 'name', 'description', 'priceInCents', 'imageUrl', 'createdAt', 'updatedAt', 'isPublished', 'moderationStatus']) &&
                       request.resource.data.priceInCents >= 50 && // Min price
                       request.resource.data.moderationStatus == 'pending';
      
      allow update: if isAuthenticated() && isResourceOwner(resource.data, "artistId") &&
                       !(request.resource.data.diff(resource.data).affectedKeys().hasAny([
                           'artistId', 'createdAt', 'moderationStatus', 'moderationInfo'
                         ]));
      allow delete: if isAuthenticated() && isResourceOwner(resource.data, "artistId");
    }

    // --- Orders ---
    match /orders/{orderId} {
      // Only buyer can read their own order. Artist access might be added later.
      allow read: if isAuthenticated() && isResourceOwner(resource.data, "userId");
      // Orders are created and updated by server/webhook only
      allow create, update, delete: if false;
    }

    // --- Notifications ---
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && isResourceOwner(resource.data, "recipientId");
      
      allow create: if false; // Created by server actions/Cloud Functions only

      allow update: if isAuthenticated() && isResourceOwner(resource.data, "recipientId") &&
                       request.resource.data.diff(resource.data).affectedKeys().hasOnly(['isRead']); // Only 'isRead' can be updated by client
      
      allow delete: if isAuthenticated() && isResourceOwner(resource.data, "recipientId");
    }

    // --- Chat Channels & Messages ---
    match /chatChannels/{channelId} {
      function isChannelMember(docData) {
        return isAuthenticated() && request.auth.uid in docData.members;
      }
      function isValidChannelIdAndMembersInRequest() {
        let parts = channelId.split('_');
        return parts.size() == 2 && parts[0] < parts[1] &&
               request.resource.data.members[0] == parts[0] &&
               request.resource.data.members[1] == parts[1];
      }

      allow read: if isChannelMember(resource.data);
      
      allow create: if isChannelMember(request.resource.data) &&
                       isValidChannelIdAndMembersInRequest() &&
                       request.resource.data.id == channelId &&
                       request.resource.data.keys().hasAll(['id', 'members', 'memberInfo', 'lastMessageText', 'lastMessageTimestamp', 'lastMessageSenderId', 'unreadCounts', 'createdAt', 'updatedAt']);

      allow update: if isChannelMember(resource.data) &&
                       (
                         // Server action updates last message details
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['lastMessageText', 'lastMessageTimestamp', 'lastMessageSenderId', 'updatedAt'])) ||
                         // Client updates their own unread count (typically to 0)
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['unreadCounts', 'updatedAt']) && 
                           request.resource.data.unreadCounts[request.auth.uid] == 0 && // Can only set their own unread to 0
                           (resource.data.unreadCounts[request.auth.uid] == null || request.resource.data.unreadCounts[request.auth.uid] <= resource.data.unreadCounts[request.auth.uid])
                         )
                       );
      allow delete: if false; // Channels not deleted by clients

      match /messages/{messageId} {
        function isChannelMemberFromParentDoc() {
          return request.auth.uid in get(/databases/$(database)/documents/chatChannels/$(channelId)).data.members;
        }
        
        allow read: if isChannelMemberFromParentDoc();
        
        allow create: if isChannelMemberFromParentDoc() && 
                         isOwner(request.resource.data.senderId) && 
                         request.resource.data.channelId == channelId &&
                         request.resource.data.keys().hasAll(['channelId', 'senderId', 'text', 'timestamp']);
                         
        allow update, delete: if false; // Messages are immutable by clients
      }
    }
  }
}

    